//
//  visitor.swift
//  swifttern
//
//  Created by Иван Галкин on 11.02.2024.
//

//
// Посетитель
// Паттерн поведения объектов.
//
// Назначение:
// Описывает операцию, выполняемую с каждым объектом из некоторой структуры.
// Паттерн посетитель позволяет определить новую операцию, не изменяя классы этих объектов.
//
// Применимость:
// - в структуре присутствуют многих классов с различными интерфейсами, и вы хотите выполнять над ними операции, зависящие от конкретных классов;
// - над объектами, входящими в состав структуры, должны выполняться разнообразные, не связанные между собой операции и вы не хотите "засорять" классы
// такими операциями. Посетитель позволяет объединить родственные операции, поместив их в один класс. Если структура объектов является общей для нескольких
// приложений, то паттерн посетитель позволит в каждое приложение включить только относящиеся к нему операции;
// - классы, определяющие структуру объектов, изменяются редко, но новые операции над этой структурой добавляются часто. При изменении классов, представленных
// в структуре, придется переопределить интерфейсы всех посетителей, а это может вызвать затруднения. Поэтому если классы меняются достаточно часто, то,
// вероятно, лучше определить операции прямо в них.
//
// Результаты:
// - упрощение добавления новы операций;
// - объединение родственных операций и отсечение тех, которые не имеют к ним отношения;
// - трудности с добавлением новых классов ConcreteElement;
// - посещение различных иерархий классов;
// - накопление состояния;
// - нарушение инкапсуляции.
//
// Родственные паттерны:
// Компоновщик: посетители могут использоваться для выполнения операции над всеми объектами структуры, определенной с помощью паттерна компоновщик.
// Интерпретатор: посетитель может использоваться для выполнения интерпретации.
//

//
// Отношения:
// - клиент, использующий паттерн посетитель, должен создать объект класса ConcreteVisitor, а затем обойти всю структуру, посетив каждый ее элемент;
// - при посещении элемента последний вызывает операцию посетителя, соответствующую своему классу. Элемент передает этой операции себя в аргументе,
// чтобы посетитель мог при необходимости получить доступ к его состоянию.
//
// Аспекты реализации:
// - двойная диспетчеризация;
// - какой участник несет ответственность за обход структуры.
//


class Client {
    init(visitor: Visitor, structure: Structure) {
        self.visitor = visitor
        self.structure = structure
    }
    
    var visitor: Visitor
    var structure: Structure
    
    func request() -> Void {
        self.structure.forEach(visitor: self.visitor)
    }
}

// Поетитель
// - объявляет операцию Visit для каждого класса ConcreteElement в структуре объектов. Имя и сигнатура этой операции идентифицируют класс, который
// посылает посетителю запрос Visit. Это позволяет посетителю определить, элемент какого конкретного класса он посещает. Владея такой информацией,
// посетитель может обращаться к элементу напрямую через его интерфейс.
protocol Visitor {
    func visitElementA(element: ConcreteElementA) -> Void
    func visitElementB(element: ConcreteElementB) -> Void
}

// Конкретный посетитель
// - реализует все операции, объявляемые в классе Visitor. Каждая операция реализует фрагмент алгоритма, определенного для класса соответствующего
// объекта в структуре. Класс ConcreteVisitor предоставляет контекст для этого алгоритма и сохраняет его локальное состояние.
// Часто в этом состоянии аккумулируются результаты, полученные в процессе обхода структуры.
class ConcreteVisitorA: Visitor {
    func visitElementA(element: ConcreteElementA) -> Void {}
    func visitElementB(element: ConcreteElementB) -> Void {}
}

class ConcreteVisitorB: Visitor {
    func visitElementA(element: ConcreteElementA) -> Void {}
    func visitElementB(element: ConcreteElementB) -> Void {}
}

// Структура объектов
// - реализует операцию Accept, принимающую посетителя как аргумент.
class Structure {
    var elements: [Element] = [];
    
    func forEach(visitor: Visitor) -> Void {
        for element in self.elements {
            element.accept(visitor: visitor)
        }
    }
}

// Элемент
// - определяет операцию Accept, которая принимает посетителя в аргументе.
protocol Element {
    func accept(visitor: Visitor) -> Void
    
    func operation() -> Void
}

// Конкретный элемент
// - реализует операцию Accept, принимающую посетителя как аргумент.
class ConcreteElementA: Element {
    func accept(visitor: Visitor) -> Void {
        visitor.visitElementA(element: self)
    }
    
    func operation() -> Void {}
}

class ConcreteElementB: Element {
    func accept(visitor: Visitor) -> Void {
        visitor.visitElementB(element: self)
    }
    
    func operation() -> Void {}
}
