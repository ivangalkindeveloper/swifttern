//
//  memento.swift
//  swifttern
//
//  Created by Иван Галкин on 09.02.2024.
//

//
// Посредник
// Паттерн поведения объектов.
//
// Назначение:
// Не нарушая инкапсуляции, фиксирует и выносит за пределы объекта его внутреннее состояние, так чтобы позднее
// можно было восстановить в нем объект.
//
// Другие названия:
// Token (лексема)
//
// Применимость:
// - необходимость сохранения снимка состояния объекта (или его части), чтобы впоследствии объект можно было восстановить
// в том же состоянии;
// - прямой интерфейс для получения этого состояния привел бы к раскрытию подробностей реализации и нарушению инкапсуляции
// объекта.
//
// Результаты:
// - сохранение границ инкапсуляции;
// - упрощение структуры хозяина;
// - потенциальные затраты при использовании хранителей;
// - определение "узкого" и "широкого" интерфейсов;
// - скрытая плата за содержание хранителя.
//
// Родственные паттерны:
// Команда: команды поещабт информацию о состоянии, необходимую для отмены выполненных действий, в хранители.
// Итератор: хранители могут использоваться для выполнения итераций.
//

//
// Отношения:
// - посыльный запрашивает хранитель у хозяина, некоторое время держит его у себя, а затем возвращает хозяину.
// Иногда этого не происходит, так как последнему не нужно восстанавилвать прежнее состояние;
// - хранители пассивны. Только хозяин, создавший хранитель, имеет доступ к информации о состоянии.
//
// Аспекты реализации:
// - языковая поддержка;
// - сохранение инкрементных изменений.
//

// Хранитель
// - сохраняет внутреннее состояниие объекта Originator. Объем сохраняемой информации может быть различным и определяется
// потребностями хозяина;
// - запрещает доступ всем другим объектам, кроме хозяина. По существу, у хранителей есть два интерфейса.
// "Посыльный" Caretaker видит лишь "узкий" интфрейс хранителя - он может только передавать хранитель объектам.
// Напротив, хозяину доступен "широкий" интерфейс, который обеспечивает доступ ко всем данным, необходимым для
// восстановления в прежнем состоянии. Идеальный вариант - когда только хозяину, создавшему хранитель, открыт доступ
// к внутреннему состоянию последнего.
class Memento {
    init(state: State) {
        self.state = state
    }
    
    var state: State;
    
    func getState() -> State {}
    
    func setState(state: State) {}
}

// Хозяин
// - создает хранитель, содержащий снимок текущего внутреннего состояния;
// - использует хранитель для восстановления внутреннего состояния.
class Originator {
    init(state: State) {
        self.state = state
    }
    
    var state: State
    
    func setMemento(memento: Memento)-> Void  {
        self.state = memento.getState()
    }
    
    func createMemento() -> Memento {
        return Memento(state: self.state)
    }
}

// Посыльный
// - отвечает за сохранение хранителя;
// - никогда не выполняет операции с хранителем и не анализирует его внутреннее содержимое.
class Caretaker {
    init(memento: Memento) {
        self.memento = memento
    }
    
    var memento: Memento
}

// Состояние
class State {}
