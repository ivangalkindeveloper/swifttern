//
//  template_method.swift
//  swifttern
//
//  Created by Иван Галкин on 11.02.2024.
//

//
// Шаблонный метод
// Паттерн поведения объектов.
//
// Назначение:
// Шаблонный метод определяет основу алгоритма и позволяет подклассам переопределить некоторые шаги алгоритма, не изменяя его структуру
// в целом.
//
// Применимость:
// - однократное использование инвариантных частей алгоритма, при этом реализация изменяющегося поведения остается на усмотрение подклассов;
// - необходимость вычленить и локализовать в одном классе поведение, общее для всех подклассов, чтобы избежать дублирования кода.
// Это хороший пример техники "вынесения за скобки с целью обощения", описанной в работе Уильяма Опдайка и Ральфа Джонсона. Сначала
// выявляются различия в существующем коде, которые затем выносятся в отдельные операции. В конечном итоге различающиеся фрагменты кода
// заменяются шаблонным методом, из которых вызываются новые операции;
// - управление расширениями подклассов. Шаблонный метод можно определить так, что он будет вызывать операции-зацепки в определенных точках,
// разрешив тем самым расщирение только в этих точках.
//
// Результаты:
// Шаблонные методы вызывают операции следующих видов:
// - конкретные операции (либо из класса ConcreteClass, либо из классов клиента);
// - конкретные операции из класса AbstractClass (то есть операции, полезные всем подклассам);
// - примитивные операции (то есть абстрактны операции);
// - фабричные методы;
// - операции-зацепки, реализующие поведение по умолчанию, которое может быть расширено в подклассах. Часто такая операция по умолчанию не делает ничего.
// Важно, чтобы в шаблонном методе четко различались операции-зацепки (которые можно замещать) и асбтрактные операции (которые нужно замещать).
//
// Родственные паттерны:
// Фабричные методы часто вызываются из шаблонных.
// Стратегия: шаблонные методы применяют наследование для модификации части алгоритма. Стратегии используют делегирование для мобификации алгоритма в целом.
//

//
// Отношения:
// - ConcreteClass предпологает, что инвариантные шаги алгоритма будут выполняться в AbstractClass.
//
// Аспекты реализации:
// - использование контроля доступа в разных языках;
// - сокращение числа примитивных операций;
// - соглашение об именах.
//

// Абстраткный класс
// - определяет абстрактные примитивные операции, замещаемые в конкретных подклассах для реализации шагов алгоритма;
// - реализует шаблонный метод, определяющий скелет алгоритма. Шаблонный метод вызывает примитивные операции, а также операции, определенные
// в классе AbstractClass или в других объектах.
protocol AbstractClass {
    func templateMethod() -> Void
    
    func primitiveOperationA() -> Void
    
    func primitiveOperationB() -> Void
}

// Конкретный класс
// - реализует примитивные операции, выполняющие шаги алгоритма способом, который зависит от подкласса.
class ConcreteClass: AbstractClass {
    func templateMethod() -> Void {
        self.primitiveOperationA()
        self.primitiveOperationB()
    }
    
    func primitiveOperationA() -> Void {}
    
    func primitiveOperationB() -> Void {}
}
