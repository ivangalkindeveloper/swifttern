//
//  interpreter.swift
//  swifttern
//
//  Created by Иван Галкин on 01.02.2024.
//

//
// Интерпретатор
// Паттерн поведения объектов.
//
// Назначение:
// Для заданного языка определяет представление его грамматики, а также интепретатор предложений этого языка.
//
// Применимость:
// Используйте паттерн интерпретатор в ситуациях, когда имеется интерпретируемый язык, конструкции которого
// можно представить в виде абстрактных синтексических деревьев. Этот паттерн лучше всего работает в следующих
// случаях:
// - грамматика проста;
// - эффективность не является главным критерием.
//
// Результаты:
// - простота изменения и расширения грамматики;
// - простая реализация грамматики;
// - сложность сопровождения сложных грамматик;
// - добавление новых способов интерпретации выражений.
//
// Родственные паттерны:
// Компоновщик: абстрактное синтаксическое дерево - пример применения паттерна компоновщик.
// Приспособленец показывает варианты разделения терминальных символов в абстрактном синтаксическом дереве.
// Итератор: интерпретатор может пользоваться итератором для обхода структуры.
// Посетитель может использоваться для инкапсуляции в одном классе поведения каждого узла абстрактного синтаксического дерева.
//

//
// Отношения:
// - клиент строит (или получает в готовом виде) конструкцию в виде асбтрактного синтаксического дерева,
// в узлах которого находятся объекты классов NonterminalExpression и TerminalExpression. Затем клиент
// инициализирует контекст и вызывает операцию Interpret;
// - в каждом узле вида NonterminalExpression через операции Interpret определяется операция Interpret для
// каждого подвыражения. Для класса TerminalExpression операция Interpret определяет базу рекурсии;
// - операции Interpret в каждом узле используют контекст для сохранения и доступа к состоянию интерпретатора.
//
// Аспекты реализации:
// - создание абстрактного синтаксического дерева;
// - определение операции Interpret;
// - разделение терминальных символов с помощью паттерна "приспособленец".
//

// Абстрактное выражение
// - объявляет абстрактную операцию Interpret, общую для всех узлов в абстрактном синтаксическом дереве&
protocol AbstractExpression {
    func interpret(context: Context)
}

// Теминальное выражение
// - реализует операцию Interpret для терминальных символов грамматики;
// - необходим отдельный экземпляр для каждого терминального символа в предложении.
class TerminalExpression: AbstractExpression {
    func interpret(context: Context) {}
}

// Нетерминальное выражение
// - по одному такому классу требуется для каждого грамматического правила R ::= R1 R2 ... Rn;
// - хранит переменные экземпляра типа AbstractExpression для каждого символа от R1 до Rn;
// - реализует операцию Interpret для нетерминальных символов грамматики. Эта операция рекурсивно вызывает
// себя же для переменных6 представляющих R1 ... Rn.
class NonterminalExpression: AbstractExpression {
    func interpret(context: Context) {}
}

// Контекст
// - содержит информацию, глобальную по отношению к интерпретатору.
class Context {}

// Клиент
// - строит (или получает в готовом виде) абстрактное синтаксическое дерево, представляющее отдельное предложение
// на языке с данной грамматикой. Дерево собирается из экземпляров классов TerminalExpression и
// NonterminalExpression;
// - вызывает операцию Interpret.
class Client {
    init(context: Context) {
        self.context = context
    }
    
    var context: Context

    func request() {
        let expression: AbstractExpression = TerminalExpression()
        expression.interpret(context: context)
    }
}
