//
//  iterator.swift
//  swifttern
//
//  Created by Иван Галкин on 08.02.2024.
//

//
// Итератор
// Паттерн поведения объектов.
//
// Назначение:
// Предоставляет способ последовательного обращения ко всем элементам составленого объекта без раскрытия
// его внутреннего представления.
//
// Другие названия:
// Cursor (курсор)
//
// Применимость:
// - обращение к содержимому агрегированных объектов без раскрытия их внутреннего представления;
// - поддержка нескольких активных обходов одного и того же агрегированного объекта;
// - предоставление единообразного интерфейса для обхода различных агрегированных структур
// (то есть для поддержки полиморжной итеграции).
//
// Результаты:
// - поддержка разных способов обхода агрегата;
// - упрощение интерфейса класса Aggregate;
// - возможность наличия нескольких активных обходов для данного агрегата.
//
// Родственные паттерны:
// Компоновщик: итераторы довольно часто применяется для обхода рекурсивных структур, создаваемых компоновщиком;
// Фабричный метод: полиморфные итераторы поручают фабричным методам создавать экземпляры подходящих подклассов
// класса Iterator.
// Итератор может использовать хранитель для сохранения состояния итерации и при этом содержит его внутри себя.
//

//
// Отношения:
// - ConcreteIterator отслеживает текущий объект в агрегате и может вычислить идущий за ним.
//
// Аспекты реализации:
// Существует множество вариантов и альтернативных способов реализации итератора, ниже перечислены
// наиболее употребительные. Выбор часто зависит от управляющих структур, поддерживаемых языком
// программирования.
// - какой участник управляет итерацией;
// - что определяет алгоритм обхода;
// - насколько итератор устойчив;
// - дополнительные операции итератора;
// - использование полиморфных итераторов;
// - возможность привилегированного доступа к итераторам;
// - итераторы для составных объектов;
// - пустые итераторы.
//

// Итератор
// - определяет интерфейс для доступа и обхода элементов.
protocol Iterator {
    func first()
    
    func next()
    
    func isDone()
    
    func currentItem()
}

// Конкретный итератор
// - реализует интерфейс класса Iterator;
// - следит за текущей позицией при обходе агрегата.
class ConcreteIterator: Iterator {
    init(aggregate: Aggregate) {
        self.aggregate = aggregate
    }
    
    var aggregate: Aggregate
    
    func first() {}
    
    func next() {}
    
    func isDone() {}
    
    func currentItem() {}
}

// Агрегат
// - определяет интерфейс для создания объекта-итерации.
protocol Aggregate {
    func createIterator() -> Iterator
}

// Конкретный агрегат
// - реализует интерфейс создания итератора и возвращает экземпляр подходящего класса ConcreteAggregate.
class ConcreteAggregate: Aggregate {
    func createIterator() -> Iterator {
        return ConcreteIterator(aggregate: self)
    }
}

// Клиента запроса
class Client {
    func request() -> Void {
        var aggregate: Aggregate = ConcreteAggregate()
        var _: Iterator = aggregate.createIterator()
    }
}
