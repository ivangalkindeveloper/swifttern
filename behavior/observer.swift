//
//  observer.swift
//  swifttern
//
//  Created by Иван Галкин on 09.02.2024.
//

//
// Наблюдатель
// Паттерн поведения объектов.
//
// Назначение:
// Определяет зависимость типо "один ко многим" между объектами таким образом, что при изменении состояния одного
// объекта все зависящие от него оповещаются об этом и автоматически обновляются.
//
// Другие названия
// Dependents (подчиненные), Publish-Subscribe (издатель-подписчик)
//
// Применимость:
// - у абстракции есть два аспекта, один из которых зависит от другого. Инкапсуляции этих аспектов в разные объекты
// позволяют изменять и повторно использовать их независимо;
// - при модификации одного объекта требуется изменить другие, и вы не знаете, сколько именно объектов нужно изменить;
// - один объект должен оповещать других, не делая предположений об уведомляемых объектах. Другими словами, объекты не
// должны быть тесно связаны между собой.
//
// Результаты:
// - абстрактная связанность субъекта и наблюдателя;
// - поддержка широковещательных коммуникаций;
// - неожиданные обновления.
//
// Родственные паттерны:
// Посредник: класс типа ChangeManager действует как посредник между субъектами и наблюдателями, инкапсулируя сложную
// семантику обновления.
// Одиночка: класс типа ChangeManager может воспользоваться паттерном одиночка, чтобы гарантировать уникальность и глобальную
// доступность менеджера изменений.
//

//
// Отношения:
// - объект ConcreteSubject уведомляет своих наблюдателей о любом изменении, которое могло бы привести к рассогласованности
// состояний наблюдателя и субъекта;
// - после получения от конкретного субъекта уведомления об изменении объект ConcreteObserver может запросить у субъекта
// дополнительную информацию, которую использует для того, чтобы оказаться в состоянии, согласованном с состоянием субъекта.
//
// Аспекты реализации:
// - связывание субъектов с наблюдателями;
// - наблюдение более чем за одним субъектом;
// - кто инициирует обновление?
// - висячие ссылки на удаленных субъектов;
// - гарантии целостности состояния субъекта перед отправкой уведомления;
// - предотвращение зависимости протокола обновления от наблюдателя;
// - явное определение модификаций, предоставляющих интерес;
// - инкапсуляция сложной семантики обновления;
// - комбинирование классов Subject и Observer.
//

// Субъект
// - распологает информацией о своих наблюдателях. За субъектом может "следить" лбое число наблюдателей;
// - предоставляет интерфейс для присоединения и отделения наблюдателей.
protocol Subject {
    func attach(observer: Observer) -> Void
    
    func detach(observer: Observer) -> Void
    
    func notify() -> Void 
}

// Конкретный субъект
// - сохраняет состояние, предоставляющее интерес для конкретного наблюдателя CocnreteObserver;
// - посылает информацию своим наблюдателям, когда происходит изменение.
class ConcreteSubject: Subject {
    var observers: [Observer] = []
    
    func attach(observer: Observer) -> Void {
        self.observers.append(observer)
    }
    
    func detach(observer: Observer) -> Void {
        var index: Int = self.observers.indexOf(after: observer)
        self.observers.remove(at: index)
    }
    
    func notify() -> Void {
        for observer in observers {
            observer.update()
        }
    }
}

// Наблюдатель
// - определяет интерфейс обновления для объектов, которые должны уведомляться об изменении субъекта.
protocol Observer {
    func update()
}

// Конкретный наблюдатель
// - хранит ссылку на объект класса Subject;
// - сохраняет данные, которые должны быть согласованы с данными субъекта;
// - реализует интерфейс обновления, определенный в классе Observer, чтобы поддерживать согласованность с субъектом.
class ConcreteObserver: Observer {
    init(subject: Subject) {
        self.subject = subject
        self.subject.attach(observer: self)
    }
    
    var subject: Subject
    
    func update() -> Void {}
}

