//
//  adapter.swift
//  swifttern
//
//  Created by Иван Галкин on 18.01.2024.
//

//
// Адаптер
// Паттерн, структурирующий классы и объекты.
//
// Назначение:
// Преобразует интерфейс одного класса в другой интерфейс, на который рассчитаны клиенты.
// Адаптер обпеспечивает совместную работу классов с несовместимыми интерфейсами, которая без него была бы невозможна.
//
// Другие названия:
// Wrapper (обертка)
//
// Применимость:
// - вы хотите использовать существующий класс, но его интерфейс не соответствует вашим потребностям;
// - требуется создать повторно используемый класс, который должен взаимодействовать с заранее незивестными
// или не связанными с ним классами, имеющими несовместимые интерфейсы;
// - (только для адаптеров-объектов!) нужно использовать несколько существующих подклассов, но непрактично адаптировать
// их интерфейсы путем порождения новых подклассов от каждого. В этом случае адаптер объектов может
// приспосабливать интерфейс их общего родительского класса.
//
// Результаты:
// Адаптеры объектов и классов обладают разными достоинствами и недостатками.
// Адаптер класса:
// - адаптирует Adaptee к Target, перепоручая действия конкретному классу Adaptee. Поэтому данный паттерн не будет работать,
// если мы захотим одновременно адаптировать класс и его подклассы;
// - позволяет адаптеру Adapter заместить некоторые операции адаптируемого класса Adaptee, так как Adapter есть не что иное,
// как подкласс Adaptee.
// - вводит только один новый объект. Чтобы добраться до адаптируемого класса, не нужно никакого дополнительного обращения
// по указателю.
// Адаптер оъектов:
// - позволяет одному адаптеру Adapter работать со многим адаптируемыми объектами Adaptee, то есть с самим Adaptee и его
// подклассами (если таковые имеются). Адаптер может добавить новую функциональность сразу всем адаптируемым объектам;
// - затрудняет замещение операций класса Adaptee. Для этого потребуется породить от Adaptee подкласс и заставить Adapter
// ссылаться на этот подкласс, а не на сам Adaptee.
// Другие аспекты, принимаемыемые решения и применени паттерна адаптер:
// - объем работы по адаптации;
// - сменные адаптеры;
// - использование двухсторонних адаптеров для обеспечения прозрачности.
//
// Родственные паттерны:
// Структура паттерна мост аналогична структуре адаптера, но у моста иноче назначение.
// Он отдаляет интерфейс от реализации, чтобы то и другое можно было изменять независимо. Адаптер же призван изменить интерфейс
// существующего объекта.
// Паттерн декоратор расширяет функциональность объекта, изменяя его интерфейс. Таким образом, декоратор более прозрачен
// для приложения, чем адаптер. Как следствие, декоратор поддерживает рекурсивную композицию, что для "чистых" адаптеров невозможно.
// Заместитель определяет представителя или суррогат другого объекта, но не изменяет его интерфейс.
//

//
// Отношения:
// - клиенты вызывают операции экземпляра адаптера Adapter. В свою очередь адаптер вызывает операции адаптируемого объекта
// или класса Adaptee, который и выполняет запрос.
//
// Аспекты реализации:
// - реализация адаптеров исходя из-за особенностей языка;
// - сменные адаптеры.
//

// Целевой
// - определяет зависящий от предменой области интерфейс, которым пользуется Client;
protocol Target: Adapter {}

// Адаптируемый
// - определяет существующий интерфейс, который нуждается в адаптации;
protocol Adaptee {
    func specificRequest()
}

// Адаптер
// - адаптирует интерфейс Adaptee к интерфейсу Target;
class Adapter: Target {
    init(adaptee: Adaptee) {
        self.adaptee = adaptee
    }
    
    var adaptee: Adaptee;
    
    func specificRequest() -> Void {
        self.adaptee.specificRequest()
    }
}

// Клиент запроса
class Client {
    init(target: Target) {
        self.target = target
    }
    
    var target: Target;
    
    func request() -> Void {
        self.target.specificRequest()
    }
}
