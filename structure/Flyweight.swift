//
//  flyweight.swift
//  swifttern
//
//  Created by Иван Галкин on 22.01.2024.
//

//
// Приспособленец
// Паттерн, структурирующий объекты.
//
// Назначение:
// Применяет совместное использование для эффективной поддержки мнодества мелких объектов.
//
// Применимость:
// Эффективность паттерна приспособленец во многом зависит от того, как и где он используется.
// Применяйте этот паттерн, когда выполнены все нижеперечисленные условия:
// - в приложении используется большое коилчество объектов;
// - из-за этого затраты на хранение высоки;
// - большую часть состояния объектов можно вынести вовне;
// - многие группы объектов можно заменить относительно небольшим коилчеством совместно используемых
// объектов, поскольку внешнее состояние вынесено;
// - приложение не зависит от идентичности объекта. Поскольку объекты-приспособленцы могут использоваться
// совместно, то проверка на идентичность возратит признак истинности для концептуально различных объектов.
//
// Результаты:
// При использовании приспособленцев возможны затраты на передачу, поиск или вычисление внутреннего состояния
// на стадии выполнения, особенно если раньше оно хранилось как внутреннее. Однако такие затраты с лихвой
// компенсируются экономией памяти за счет совместного использования объектов-приспособленцев.
// Экономия памяти обсуловлена несколькими причинами:
// - уменьшение общего числа экземпляров;
// - сокращение объема памяти, необходимого для хранения внутреннего состояния;
// - вычисление, а не хранение внешнего состояния (если это действительно так).
// Чем выше степень совместного использования приспособленцев, тем существеннее экономия. С увеличением
// объема совместного состояния экономия также возрастает. Самого большого эффекта удается добиться, когда
// суммарный объем внутренней и внешней информации о состоянии велик, а внешнее состояние вычисляется, а не хранится.
// Тогда совместное использование уменьшает стоимость хранения внутреннего состояния, а за счет вычислений
// сокращается память, отводимая под внешнее состояние.
// Паттерн приспособленец часто применяется вместе с компоновщиком для представления иерархической структуры
// в виду графа с совместно используемыми листовыми узлами. Из-за разделения указатель на родителя не может храниться
// в листовом узле-приспособленце, а должен передаваься ему как часть внешнего состояния. Это оказывает заметное влияние
// на способ взаимодействия объектов иерархии между собой.
//
// Родственные паттерны:
// Паттерн приспособленец часто используется в сочетании с компоновщиком дял реализации логической иерархической
// структуры в виде ациклического направленного графа с совместно используемыми листовыми вершинами.
// Часто наилучшим способом реализации объектов состояния и стратегии является паттерн приспособленец.
//

//
// Отношения:
// - состояние, енобходимое приспособленцу для нормальной работы, классифицируется на внутреннее или внешнее.
// Внутреннее состояние хранится в самом объекте ConcreteFlyweight. Внешнее состяоние хранится или вычисляется
// клиентами. Клиент передает его приспособленцу при вызове операций;
// - клиенты не должны создавать экземпляры класса ConcreteFlyweight напрямую, а могут получать их только от
// объекта FlyweightFactory. Это позволит гарантировать корректное совместное использование.
//
// Аспекты реализации:
// - вынесение внешнего состояния;
// - управление совместно используемыми объектами.
//

// Приспособленец
// - объявляет интерфейс, с помощью которого приспособленцы могут получать внешнее состояние
// или как-то воздействовать на него;
class Flyweight {
    init(key: String) {
        self.key = key
    }
    
    var key: String
    
    func operation() {}
}

// Конкретный приспособленец
// - реализует интерфейс класса Flyweight и добавляет при необходимости внутреннее состояния.
// Объект класса ConreteFlyweight должен быть совместно используемым. Любое сохраняемое им состояние
// должно быть внутренним, то есть не зависящим от контекста.
class ConreteFlyweight: Flyweight {
    var intrinsicState: String = "intrinsicState"
    
    override func operation() {}
}

// Кокнретный приспособленец, не используемый совместно
// - не все подклассы Flyweight обязательно должны быть совместно используемыми.
// Интерфейс Flyweight допускает совместное использование, но не навязывает его.
// Часто у объектов UnsharedConreteFlyweight на некотором уровне структуры приспособленца
// есть потомки в виде объектов класса ConreteFlyweight, как, анпример, у объектов
// классов Row и Column 
class UnsharedConreteFlyweight: Flyweight {
    let allState: String = "allState"
    
    override func operation() {}
}

// Фабрика приспособленцев
// - создает объекты-приспособленцы и управляет ими;
// - обепечивает совместное использование приспособленцев. Когда клиент запрашивает приспособленца,
// объект FlyweightFactory предоставляет существующий экзмепляр или создает новый, если
// готового еще нет.
class FlyweightFactory {
    private var flyweights: {Flyweight} = {};
    
    func getFlyweight(key: String) -> Flyweight {
        var currentFlyweight: Flyweight? = self.flyweights[key]
        if (currentFlyweight != nil) {
            return currentFlyweight;
        } else {
            var newFlyweight: Flyweight = Flyweight(key)
            flyweights[key] = newFlyweight
            return newFlyweight
        }
    }
}

// Клиент запроса
// - хранит ссылки на одного или несколькиз приспособленцев;
// - вычисляет или хранит внешнее состояние преспособленцев;
class Client {
    var flyweightFactory: FlyweightFactory = FlyweightFactory()
    
    func request() {
        var flyweight: Flyweight = self.flyweightFactory.getFlyweight("Key")
        flyweight.operation()
    }
}
