//
//  prototype.swift
//  swifttern
//
//  Created by Иван Галкин on 14.01.2024.
//

//
// Прототип
// Паттерн, порождающий объекты.
//
// Назначение:
// Задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа.
//
// Применимость:
// Используйте паттерн прототип, когда система не должна зависеть от того, как в ней создаются, компонуются и представляются продукты.
// - классы для создания экземпляров определяются во время выполнения, например с помощью динамической загрузки;
// - для того чтобы избежать построения иерархий классов или фабрик, параллельных иерархий классов продуктов;
// - экземпляры класса могут находится в одном из не очень большого числа различных состояния. Может быть удобнее установить
// соответствующее число прототипов и клонировать их, а не создавать экземпляр каждый раз вручную в подходящем состоянии.
//
// Результаты:
// У прототипа те же самые результаты, что и у абстрактной фабрики и строителя: он скрывает от клиента конкретнуые классы продуктов,
// уменьшая тем самым число известных клиенту имен. Кроме того, все эти паттерны позволяют клиентам работать с классами,
// специфичными для приложения, без модификаций.
// Дополнительные преимущества:
// - добавление и удаление продуктов во время выполнения;
// - определение новых объектов путем изменения значений;
// - определение новых объектов путем изменения структуры;
// - уменьшение числа подклассов;
// - динамическая настройка конфигурации приложения класса.
// Основной недостаток паттерна прототип заключается в том, что каждый подкласс класса Prototype должен реализовывать операцию Clone,
// а это далеко не всегда просто. Например, сложно добавить операцию Clone, если рассматриваемые классы уже существуют.
// Проблемы возникают и в случае, если во внутреннем представлении объекта присутствуют другие объекты,
// не поддерживающие копирования, или наличествуют циклические ссылки.
//
// Родственные паттерны:
// В некоторых отношениях прототип и абстрактная фабрика является конкурентами.
// Они могут использоваться совместно. Абстрактная фабрика может хранить набор прототипов, которые клонируются и возвращают
// изготовленные объекты.
// В тех проектах, где активно применяются паттерны компоновщик и декоратор, тоже извлечь пользу из прототипа.
//

//
// Отношения:
// Клиент образается к прототипу, чтобы тот создать свою копию.
//
// Аспекты реализации:
// Прототип особенно полезен в статически типизированных языках, где классы не являются объектами, а во время выполнения
// информации о типе недостаточно или нет вовсе.
// - использование диспетчера прототипов;
// - реализация операции Clone;
// - инициализация клонов.
//

// Прототип
// - объявляет интерфейс для клонирования самого себя.
protocol Prototype {
    func clone() -> Prototype
}

// Конкретный прототип
// - реализует операцию клонирования себя.
class ConcretePrototype: Prototype {
    func clone() -> Prototype {
        return ConcretePrototype()
    }
}

// Клиент запроса
// - создает новый объект, обращаясь к прототипу с запросом клонировать себя.
class Client {
    init(prototype: Prototype) {
        self.prototype = prototype
    }
    
    var prototype: Prototype
    
    func opreation() {
        self.prototype = self.prototype.clone()
    }
}
